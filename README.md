# GChain

主に初学者を対象として、各画像処理をどう組み合わせれば良いかを学ぶためのツールです。

# 操作方法

1. 画面右のコンボボックスから、適当に 1 つ関数を選択します（最初は、「画像の読み込み」を選択することをお勧めします）。
2. 然るべきパラメータを入力し、「追加」を押します。
3. 画面上または下のコンボボックスから、繋げたい関数を選択します。
   ここで選択できる関数は、最初に選択した関数に自身の戻り値を渡せる、あるいは、最初に選択した関数の戻り値を自身の引数で受け取れるもの、すなわち繋げられるものになっています。
4. 然るべきパラメータを入力し、「上・下に追加」を押します。
5. リストボックスに、関数が追加されます。また、画面右にプレビューが表示されます。
6. 3.～ 5.を繰り返して、好きなだけ関数を繋げていきます。
7. 画面下の「コード生成」を押し、Python コードを生成します。

# 作成した動機

まず、自分の経歴を盛り込もうと考え、画像処理を用いたデスクトップアプリを作成しようと考えました。
また、内部的には、自分の関心があるソフトウェア設計や型システムを取り入れて作成しようと決めました。

次に、どのような題材にするかを考えた際、経歴を振り返ると、自分が初学者だったときのことを思い出しました。そして、以下のような体験をしていたことに気が付きました。

1. どの処理に何が必要か全く分からなかった
2. 入出力の型と格闘していた
3. 頭の中で処理の経過をイメージしながらコードを書くのは難しかった

以上の体験はおよそ初学者に共通だろうと考え、これを解決するアプリを作ってみてはどうかと思い、本アプリを作成しました。

# アプローチ

まず、 1.に対処するため、出発点になる処理や、最終的に行いたい処理を決めて、続く・繋がる処理を選んでいくような操作が思い浮かびました。

次に、2.に対処するため、前述の選んでいく操作で選べる操作は、実行可能なもののみ選び出すような操作になるのが望ましいです。
またこの際、型システムを取り入れることで、そうした選び出す処理が、コンパイル時点で正しいものになったり、後々処理を追加した際に対応漏れ等に気付けることを期待しました。

最後に、3.に対処するため、操作に応じて更新されていくプレビューを作成することを決めました。
さらに、コードを書くのが難しいなら生成してしまってはどうかとも考え、コード生成機能を付けることにしました。

# 実装

画像処理のライブラリとして OpenCVSharp(C#版の OpenCV)を、UI ライブラリとして WPF および Livet を選定しました。
いずれも現職で長く採用しており、使い慣れているためです。
また、OpenCV は画像処理ライブラリとして人気があります。

本アプリでは、主に以下の 2 点を取り扱います。

1. 関数を繋げていく操作
2. 繋げた関数からコード生成

この 2 点をどうコードで表現するか、どう安全に行うかが実装の上での課題となっていました。

1.についてですが、一般的に、ある戻り値を持つ関数は、その戻り値を持つ関数の引数に置いて合成できる、つまり繋げることができます。本アプリではこの性質をコードで表現するため、様々な型を導入しています。
本アプリで使用する関数（以下、画像処理関数）とは、OpenCV で提供されている関数の中から選び出され、IFunction を実装させたクラスにラップしたものです。IFunction 自体は何もメンバーを持たないインターフェースですが、後述するように実装漏れの低減に活用します。
また、画像処理関数の大部分は IFunction<TIn, TOut>を実装しており、これは TIn を引数に、TOut を戻り値に持つことを表しています。つまり、繋げる操作を行う際に必要な情報を、型で表しています。一部、実装しないものがありますが、これはエントリポイント（処理の開始点）としてのみ使われるためで、引数（より正確には、前に繋げられる画像処理関数）を持ちません。
画像処理関数を追加する場合は、IFunction の Match にも処理を追加します。こうすることで、Match を使用している部分については、変更時にコンパイルエラーが発生するようになり、例えば各画像処理関数に応じた表示処理などの実装漏れを低減することができます。

画像処理関数の TIn, TOut は Value という型を継承した型である必要があります。Value は画像処理関数の間でやり取りされる値の型を表しています。また、これも IFunction と同様に Match で対応漏れを低減するような仕組みが導入されています。

こうした関数の繋がりは、Chain という形で表現されます。Chain は逆に探索を行うリストのような構造をしています。これは、逆伝播的に再帰するような構造の方が、型システムとの相性が良かったためです。また、例えば Evaluate や GenerateCode する再は最後尾の Chain から呼び出すことになるため、モデリングの上でも直感に近くなります。さらに Chain は、自身の前に繋がる要素の型を、型引数の形で受け取ることで制約しています。これは、キャスト等を使わず、安全に画像処理関数を繋げていくことを意図しています。つまり、BgrMatrix を出力する画像処理関数に GrayMatrix を引数に取る画像処理関数を繋げてしまった、というようなミスが、コンパイル時点で発生しないことを意図しています。

そして、2.についてですが、繋げた関数を元にコード生成を行います。
各 Chain では、自身の前に繋げられた関数から、現状生成されたコードと、コード生成で使用した変数名を受け取り、自身が生成したコードと、自身が使用した変数名を返します。これを再帰的に行うことで、先頭から末尾までのコードを連結し、最終的なコードを生成します。
生成されたコードは、import 文を追加するなどの適当な修正を行うことで、そのまま Python コードとして実行できるようになっています。

# 改善点

1. 元に戻す機能
   現状では操作を間違えると一からやり直しになってしまうため、この機能は必要なように思います。

2. 型システムの見直し
   例えば、Usecase.Handle の引数を、IFunction ではなく Chain を受け取るようにすることで、コードがより簡潔になる可能性があります。
   EntryPoint かどうかで Usecase を分けていますが、統合できるかもしれません。

3. プレビューの更新
   関数の前に関数を繋げた場合、プレビューが更新されません。
   画像の読み込みを追加したときなど、適切なタイミングでプレビューの更新を行うようにしたいと思います。

4. 多引数への対応
   現状のコードは、2 つ以上の引数を取る関数に対応していません。例えば Mat2 つを引数に取る Subtract 関数などは追加することができません。
   また、現状の Chain の定義等とも相性が悪く、簡単には追加できないと思われます。
   Chain の定義を見直すなどして、機能追加しやすい形にしたいと思います。
